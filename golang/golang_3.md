# 函数

## 函数声明

函数声明包括函数名、形式参数列表、返回值列表、函数体。

```
func funcname(parameter-list) (result-list) {
	body
}
```

**形参**

形式参数列表描述了函数的参数名和参数类型。这些参数作为局部变量，其值由参数调用者提供。

**返回值**

返回值列表提供了函数返回值的变量名和类型。若函数返回了一个无名变量或无返回值，则返回值列表的括号可以省略。

返回值也可以像形式参数一样被命名，此时，每个返回值被声明成一个局部变量，并根据该返回值的类型被初始化为对应的零值。

如果一组形式参数或返回值有相同的类型，可以不必为每个参数或返回值都明确指定类型：

```go
func (i, j, k int) (a, b int) {...}
```

**函数标识符**

函数的类型被称为函数的标识符。如果两个函数的形式参数类型和返回值类型一一对应，则认为这两个函数有相同的类型和标识符。型参和返回值的变量名不影响函数标识符。

**函数参数没有默认值**

golang中每次函数调用必须按照声明顺序为所有参数提供实值，golang没有默认参数值，也没有方法可以通过参数名指定型参。

**函数参数传递**

函数体中，函数的型参作为局部变量，被初始化为调用者提供的值。函数的型参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。

实参通过值的方式传递，因此函数的形参是实参的拷贝。对型参的修改不会影响实参。但如果实参包含引用类型，如指针、slice、map、function、channel等类型，实参可能会由于函数的间接引用被修改。

**无函数体的函数声明**

还有一些没有函数体的函数声明，这表明该函数不是以golang实现的，这样的声明定义了函数表示符。

## 递归

**可变递归栈**

大部分编程语言使用固定大小的函数调用栈，常见的大小从64kb到2mb不等。固定大小的栈会限制递归的深度，当使用大量递归时，需要注意避免栈溢出，除此之外，还会导致安全性问题。

golang使用可变栈，栈的大小按需增加，初始时很小，这使得使用递归时不必考虑溢出和安全问题。

## 多返回值

golang中一个函数可以返回多个值。

调用多返回值函数时，返回给调用者的是一组值，调用者必须显式地将这些值分配给变量。如果某个值不被使用，可以将其分配给`_`空白符。

当调用一个接受多个参数的函数时，可以将一个返回多个参数的函数作为它的参数。

**bare return**

如果一个函数的所有返回值都有显式的变量名，那么函数的return语句可以省略操作数，称之为bare return。函数会安装返回值列表的次序返回所有的返回值。

bare return可能会导致代码不易理解，不宜过度使用。

## 错误

**panic异常**

panic是来自被调函数的信号，表示发生了某个已知的bug。一个良好的程序永远不应该发生panic异常。

在golang的错误处理中，错误是软件包api和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。

对于哪些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，用来传递错误信息。如果导致失败的原有只有一个，那额外的返回值可以是一个布尔值，通常命名为ok。

```go
value, ok := cache.Lookup(key)
if !ok {
	...
}
```

通常，失败原因不止一种，因此，额外的返回类型不再是简单的布尔值，而是error类型。error是内置的接口类型，返回的error可能是nil或non-nil，nil表示函数运行成功，否则表示运行失败。

可以通过调用error类型的Error函数或输出函数获取字符串类型的错误信息。

golang使用控制流机制处理异常，这使得编码人员能更多的关注错误处理。

### 错误处理策略

当一次函数调用返回错误时，应该选择合适的方式处理错误。这里有常用的5中处理方式。

**传播错误**

意味着函数中某个子程序的失败会变成该函数的失败。

```go
resp, err := http.Get(url)
if err != nil {
	return nil, err
}
```

**重新尝试失败的操作**

如果错误的发生是偶然性的，或者由不可预知的问题导致的，一个明智的选择是重新尝试失败操作。

在重试时需要设置时间间隔或重试次数，防止无限制的重试。

**输出错误信息并结束程序**

如果错误发生后，程序无法继续运行，就可以采取输出错误信息并结束程序的策略。

注意：这种策略只应在main函数中使用。对于库函数而言，应仅向上传播错误，除非该错误意味着程序内部出现不一致性，即出现流bug，才能在库函数中结束程序。

```go
if err := WaitForServer(url); err != nil {
	fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
	os.Exit(1)
}
```

**输出错误信息**

有时我们只需要输出错误信息就可以了，并不需要中断程序，可以使用log包提供的函数。

```go
if err := Ping(url); err != nil {
	log.Printf("ping failed: %v; networking disabled", err)
}
```

**忽略错误**

最后一种策略：忽略错误。

**错误处理编码风格**

在golang中，错误处理有一套独特的编码风格。

检查某个子函数是否失败后，通常将处理失败的逻辑放在处理成功的代码之前。

如果某个错误会导致函数返回，那么成功时的逻辑代码不应该放在else语句块中，而应该直接放在函数体中。

## 函数值

golang中，函数被看作第一大值：函数像其他值一样，拥有类型，可以赋值给其他变量，传递给函数，从函数返回。

对函数值的调用类似函数调用。

```go
func testfun() int {...}

f := testfun
f()
```

**函数类型零值**

函数类型的零值是nil。

调用值为nil的函数值会英法panic错误。

**函数值之间不能比较**

函数值可以与nil比较

```go
var f func(int) int
if f != nil {
	f(3)
}
```

但是函数值之间不能比较，也不能用函数值做map的key。

## 匿名函数

拥有函数名的函数只能在包级语法块中被声明。

**函数字面量**

通过函数字面量（function literal），可以绕过这一限制，在任何表达式中表示一个函数值。

函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数。

函数字面量允许我们在使用函数时，再定义它。更为重要的是，通过这种方式定义的函数可以访问完整的词法环境，这意味着在函数中定义的内部函数可以引用该函数的变量（函数闭包）。函数值不仅仅是一串代码，还记录了状态，golang使用闭包技术实现函数值。

**匿名函数递归**

当匿名函数需要被递归调用时，必须首先声明一个变量，再将匿名函数赋值给这个变量。如果不分成两部，函数字面量无法与匿名函数绑定，也无法递归调用该匿名函数。

```go
testfunc := func(a int) int {
	return testfunc(a) // compile error
}

// 可以的
var testfunc func(a int) int
testfunc = func(a int) int {
    return testfunc(a)
}
```

### 警告：捕获迭代变量

```go
var rmdirs []func()
for _, d := range tempDirs() {
	dir := d // NOTE: necessary!
	os.MkdirAll(dir, 0755) // creates parent directories too
	rmdirs = append(rmdirs, func() {
		os.RemoveAll(dir)
	})
}

// ...do some work…
for _, rmdir := range rmdirs {
	rmdir() // clean up
}
```

注意：循环体中用循环变量d赋值一个新的局部变量，而不是直接使用循环变量dir。

原因在于循环变量的作用域。for循环语句引入了新的词法块，循环变量dir在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以dir为例，后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。这意味着，每次对os.RemoveAll的调用删除的都是相同的目录。

通常，为了解决这个问题，我们会引入一个局部变量，保存循环变量的副本。

## 可变参数

参数数量可变的函数称为为可变参数函数。

在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“...”，这表示该函数会接收任意数量的该类型参数。

```go
func sum(vals...int) int {
	total := 0
	for _, val := range vals {
		total += val
	}
	return total
}
```

在函数体中，vals被看作是类型为[] int的切片。sum可以接收任意数量的int型参数。

```go
fmt.Println(sum(1, 2, 3, 4))
```

当调用者传入多个参数时，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数。

如果原始参数已经是切片类型，只需在最后一个参数后加上省略符，即可达到传入多个参数一样的效果。

```go
values := []int{1, 2, 3, 4}
fmt.Println(sum(values...)) // "10"
```

虽然在可变参数函数内部，...int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。

```go
func f(...int) {}
func g([]int) {}
fmt.Printf("%T\n", f) // "func(...int)"
fmt.Printf("%T\n", g) // "func([]int)"
```

## Deferred函数

只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。

当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。

可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。

defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。

释放资源的defer应该直接跟在请求资源的语句后。

defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。

在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。一种解决方法是将循环体中的defer语句移至另外一个函数。在每次循环时，调用这个函数。

## Panic异常

Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。

当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。

panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。

不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径。

由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。

对于大部分漏洞，应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。

## Recover捕获异常

通常来说，不应该对panic异常做任何处理，但有时，也许可以从异常中恢复，至少可以在程序崩溃前，做一些操作。

如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。

不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。

虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，不应该试图去恢复其他包引起的panic。

公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为无法确保这样做是安全的。

安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复，可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理。